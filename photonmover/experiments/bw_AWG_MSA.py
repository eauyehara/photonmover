
from photonmover.Interfaces.Experiment import Experiment
from photonmover.utils.plot_utils import plot_graph

# Interfaces/instruments necessary for the experiment
# - You use an Interface if any instrument of that category can be used
# - You use a specific instrument if you can only use that specific model
from photonmover.Interfaces.MSA import MSA
# from photonmover.Interfaces.WaveformGenerator import WaveformGenerator
from photonmover.Interfaces.SignalGenerator import SignalGenerator

# This is only necessary for the example
from photonmover.instruments.Microwave_spectrum_analyzers.KeysightN9000B import KeysightN9000B
# from photonmover.instruments.Arbitrary_waveform_generators.Agilent81180A import Agilent81180A
from photonmover.instruments.signal_generators.AnritsuMG3692B import AnritsuMG3692B

# General imports
import time
import numpy as np
import csv

class BW_AWG_and_MSA(Experiment):

    def __init__(self, instrument_list, visa_lock=None):
        """
        :param instrument_list: list of available instruments. IMPORTANT:
        WE ASSUME THAT THE INSTRUMENTS HAVE BEEN INITIALIZED ALREADY!
        """
        super().__init__(visa_lock)

        # It is always good practice to initialize variables in the init

        # Instruments
        self.awg = None
        self.msa = None

        self.data = None

        if not self.check_necessary_instruments(instrument_list):
            raise ValueError(
                "The instruments for this experiment are not present!")

    def check_necessary_instruments(self, instrument_list):
        """
        Checks if the instruments to perform the experiment are present.
        :param instrument_list: list of the available instruments
        :return: True if the instruments are present, False otherwise.
        """

        for instr in instrument_list:
            # if isinstance(instr, WaveformGenerator):
            if isinstance(instr, AnritsuMG3692B):
                self.awg = instr
            if isinstance(instr, MSA):
                self.msa = instr

        if (self.msa is not None) and (self.awg is not None):
            return True
        else:
            return False

    def get_description(self):
        """
        Returns a string with a brief summary of the experiment.
        """
        return """ Performs a bandwidth measurement by sweeping
             the frequency of a sinusoid generated by an AWG
             and measures the response using an MSA. It can
             also sweep amplitude and offset. """

    def get_name(self):
        """
        Returns a string with the experiment name
        """
        return "Bandwidth AWG+MSA"

    def perform_experiment(self, params, filename=None):
        """
        Performs the experiment, and saves the relevant data (if there is any)
        to the specified file (if given)
        :param params: dict of the parameters necessary for the experiment.
        :param filename: if specified, the data is saved in the specified file.
        :return:
        """

        params = self.check_all_params(params)

        biases = params["voltages"]
        amps = params["amplitudes"]
        freqs = params["freqs"]
        atten = params["atten"]
        rbw = params["rbw"]

        #Configure MSA bandwidth, frequency window
        buffer = 50e3
        points = 8000 #affects frequency resolution
        self.msa.set_acq_bandwidth(rbw,rbw)
        self.msa.set_freq_axis(start_freq=str(freqs[0]-20e3)+'Hz', end_freq=str(freqs[-1]+buffer)+'Hz')
        self.msa.set_num_points(points)

        # self.awg.set_waveform('SIN', freqs[0], amps[0], biases[0])
        self.awg.set_frequency(freqs[0])
        self.awg.set_power(amps[0])
        self.awg.turn_on()
        time.sleep(1)

        for offset in biases:
            for amp in amps:

                print(
                    # 'Starting freq sweep for offs %.4f mV, amp %.4f mV...' %
                    # (offset * 1e3, amp * 1e3))
                    'Starting freq sweep for amp %.4f dBm...' %
                    amp)

                # Configure AWG and turn on
                # self.awg.set_waveform('SIN', freqs[0], amp, offset)
                self.awg.set_power(amp)
                self.awg.turn_on()

                peak_freqs = []
                peak_amps = []

                # Sweep frequency and get spectrum for each one
                for freq in freqs:

                    print('Measuring %.4f MHz...' % (freq * 1e-6))

                    # Change the frequency of the applied signal
                    # self.awg.set_frequency(freq)
                    self.awg.set_frequency(freq)
                    print('Set AWG Freq')
                    # Wait 1 second
                    time.sleep(0.5)

                    # Set the MSA to get the signal of interest
                    # freq_string = "%.4f MHZ" % (freq * 1e-6)
                    # span_string = "%.4f MHZ" % np.minimum(
                    #     np.maximum((2 * freq * 1e-6), 0.5), 1)
                    # self.msa.set_freq_axis(
                    #     freq_string, span_string, None, None)
                    # time.sleep(2)

                    # Wait for MSA sweep and data read
                    time.sleep(msa.get_sweep_time()+1.0)
                    # Get peak information
                    f_peak, amp_val = self.msa.get_peak_info()
                    peak_freqs.append(f_peak)
                    peak_amps.append(amp_val)
                    print(
                        'Peak at %.4f MHz with strength %.4f dB' %
                        (f_peak * 1e-6, amp_val))

                    # Get the spectrum and save it
                    time_tuple = time.localtime()

                    # if filename is not None:
                    #     file_name = "%s-freq=%.4fMHz-Vgs_amp=%.3fV-Vgs_offs=%.3fV--%d#%d#%d_%d#%d#%d.csv" % (
                    #         filename,
                    #         freq * 1e-6,
                    #         amp,
                    #         offset,
                    #         time_tuple[0],
                    #         time_tuple[1],
                    #         time_tuple[2],
                    #         time_tuple[3],
                    #         time_tuple[4],
                    #         time_tuple[5])
                    # else:
                    #     file_name = None
                    #
                    # self.msa.read_data(file_name)
                    #
                    # print('Got trace for offset %.4f mV...' % (offset * 1e3))
                    # print('-----------------------------')

                if filename is not None:
                    summary_filename = "%s-S21_freqs=%.0e-%.0eHz-V_amp=%.2fV-V_offs=%.2fV-atten=%ddB--%d-%d-%d_%d-%d-%d.csv" % (
                        filename,
                        freqs[0],
                        freqs[-1],
                        amp,
                        offset,
                        atten,
                        time_tuple[0],
                        time_tuple[1],
                        time_tuple[2],
                        time_tuple[3],
                        time_tuple[4],
                        time_tuple[5])
                    # Save the peak vs frequency data
                    with open(summary_filename, 'w+') as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerow(freq_list)
                        writer.writerow(peak_freqs)
                        writer.writerow(peak_amps)

        self.data = [peak_freqs, peak_amps]
        self.awg.turn_off()

        return [peak_freqs, peak_amps]

    def required_params(self):
        """
        Returns a list with the keys that need to be specified
        in the params dictionnary, in order for
        a measurement to be performed
        """
        return ["voltages", "amplitudes", "freqs"]

    def plot_data(self, canvas_handle, data=None):

        if data is None:
            if self.data is not None:
                data = self.data
            else:
                raise ValueError(
                    'plot_data was called before performing the '
                    'experiment or providing data')

        peak_freqs = data[0]
        peak_amps = data[1]

        plot_graph(
            x_data=peak_freqs,
            y_data=peak_amps,
            canvas_handle=canvas_handle,
            xlabel='Peak Frequency (Hz)',
            ylabel='Peak amplitude (dBm)',
            title='AWG+MSA',
            legend=None)


import sys
# from pyqtgraph.Qt import QtGui, QtCore
from PyQt5 import QtGui, QtCore, QtWidgets
import pyqtgraph as pg

# class Window(QtGui.QMainWindow):
class Window(QtWidgets.QMainWindow):
    def __init__(self):
        super(Window, self).__init__()
        self.setGeometry(100, 100, 1000, 500)
        self.setWindowTitle("S21")

        # Menu definition
        mainMenu = self.menuBar()

        # Set Window as central widget
        # self.w = QtGui.QWidget()
        self.w = QtWidgets.QWidget()
        self.setCentralWidget(self.w)

        ## Create a grid layout to manage the widgets size and position
        # self.layout = QtGui.QGridLayout()
        self.layout = QtWidgets.QGridLayout()
        self.w.setLayout(self.layout)

        # plot widget
        self.p_power = pg.PlotWidget()
        self.xlabel = self.p_power.setLabel('bottom', text='Frequency', units='Hz')
        self.ylabel = self.p_power.setLabel('left', text='Power', units='dBm')
        self.layout.addWidget(self.p_power, 0, 0)

        self.p_power_handle = self.p_power.plot(pen=(1, 3))

        self.show()


    def plot(self, x, y):
        self.p_power_handle.setData(x,y)

if __name__ == '__main__':

    # INSTRUMENTS
    msa = KeysightN9000B()
    # awg = Agilent81180A()
    awg = AnritsuMG3692B()

    msa.initialize()
    awg.initialize()

    # EXPERIMENT PARAMETERS
    device = "LNA_MITEQ_AFS42-00101000_0.1-10GHz_100pts" #'PD_818-BB-35F_CALIB'
    # device = "LNA_MITEQ_AFS42-00101000_1-100MHz_100pts" #'PD_818-BB-35F_CALIB'
    atten = 18  # [dB] attenuation after awg
    rbw = '500kHz'# MSA rbw

    vgs_amp = [-20] #dBm #[0.050] #Agilent81180A min Vpp=50mV
    vgs_offset = [0]


    start_freq = 100e6
    end_freq = 10e9
    num_freq = 100
    log_sweep = False  # If True, it does a logarithmic sweep
    if log_sweep:
        freq_list = np.logspace(
            np.log10(start_freq),
            np.log10(end_freq),
            num_freq)
    else:
        freq_list = np.linspace(start_freq, end_freq, num_freq)

    base_file_name = './data/' + device

    # SET UP THE EXPERIMENT
    instr_list = [msa, awg]
    exp = BW_AWG_and_MSA(instr_list)
    params = {
        "voltages": vgs_offset,
        "amplitudes": vgs_amp,
        "freqs": freq_list,
        "atten": atten,
        "rbw": rbw}

    # RUN IT
    [peak_freqs, peak_amps] = exp.perform_experiment(params, filename=base_file_name)

    # PLOT DATA
    # app = QtGui.QApplication(sys.argv)
    app = QtWidgets.QApplication(sys.argv)
    GUI = Window()
    GUI.plot(peak_freqs, peak_amps)

    # CLOSE INSTRUMENTS
    msa.close()
    awg.close()

    sys.exit(app.exec_())